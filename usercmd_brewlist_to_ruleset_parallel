#!/usr/bin/env bash

# 确定 Homebrew 的安装路径
if [ -x /usr/local/bin/brew ]; then
  BREW_PREFIX="/usr/local"
elif [ -x /opt/homebrew/bin/brew ]; then
  BREW_PREFIX="/opt/homebrew"
else
  echo -e "Homebrew 未找到"
  exit 1
fi

# 获取已安装的 formulae 和 casks
FORMULAE=$($BREW_PREFIX/bin/brew list --formula)
CASKS=$($BREW_PREFIX/bin/brew list --cask)

# 创建临时目录存储并行处理结果
TEMP_DIR=$(mktemp -d)
ERROR_LOG="${TEMP_DIR}/error.log"

# 创建临时脚本文件
TEMP_SCRIPT="${TEMP_DIR}/get_url.sh"
cat << 'EOF' > "$TEMP_SCRIPT"
#!/bin/bash
BREW_PREFIX="$1"
PKG="$2"
TYPE="$3"
TEMP_DIR="$4"
ERROR_LOG="$5"

get_url_from_json() {
  local pkg=$1
  local type=$2
  local json_output
  if [ "$type" == "formula" ]; then
    json_output=$($BREW_PREFIX/bin/brew info --json=v2 --formula "$pkg" 2>/dev/null)
  else
    json_output=$($BREW_PREFIX/bin/brew info --json=v2 --cask "$pkg" 2>/dev/null)
  fi

  if echo -e "$json_output" | jq -e '.' > /dev/null 2>&1; then
    local url
    if [ "$type" == "formula" ]; then
      url=$(echo -e "$json_output" | jq -r '.formulae[0].urls.stable.url // empty')
    else
      url=$(echo -e "$json_output" | jq -r '.casks[0].url // empty')
    fi
    if [ -n "$url" ]; then
      echo -e "$url"
    else
      echo -e "无法提取 $pkg 的 URL" >> "$ERROR_LOG"
      echo -e ""
    fi
  else
    echo -e "无法解析 $pkg 的 JSON 输出" >> "$ERROR_LOG"
    echo -e ""
  fi
}

URL=$(get_url_from_json "$PKG" "$TYPE")
if [ -n "$URL" ]; then
  DOMAIN=$(echo -e "$URL" | sed -E 's|https?://([^/]+).*|\1|')
  echo -e "$DOMAIN" > "${TEMP_DIR}/${TYPE}_${PKG}.domain"
  if [ "$TYPE" == "formula" ]; then
    echo -e "brew install $PKG" > "${TEMP_DIR}/${TYPE}_${PKG}.command"
  else
    echo -e "brew install --cask $PKG" > "${TEMP_DIR}/${TYPE}_${PKG}.command"
  fi
fi
EOF

chmod +x "$TEMP_SCRIPT"

# -----------------------------------------------------------------------------
# GNU Parallel configuration
#
# Newer versions of GNU Parallel are more conservative about the characters they
# accept in the current working directory and will print warnings or refuse to
# run unless you explicitly acknowledge the risks.  They also display a
# citation notice on every invocation unless the user confirms they will cite
# the tool.  According to the official GNU Parallel documentation, running
# `parallel --citation` will print the citation notice and silence it for
# future runs, and the `--will-cite` option will silence the notice for the
# current run【876478828081736†L880-L903】.  The same documentation notes that
# the `--unsafe` flag allows Parallel to run in directories containing
# characters outside of its conservative default set【876478828081736†L4056-L4067】.
# To avoid repeated warnings and interactive prompts, we create the
# ~/.parallel/will-cite file once and pass the --unsafe flag when invoking
# parallel.  Creating ~/.parallel/will-cite is equivalent to acknowledging
# that you will cite GNU Parallel; this suppresses the nag for future runs as
# demonstrated in the official guidance【876478828081736†L880-L903】.

# Silence the citation notice permanently by creating the will‑cite file.  If
# ~/.parallel does not exist, create it.  Touching will‑cite here means GNU
# Parallel will skip the citation notice in subsequent runs.
mkdir -p "${HOME}/.parallel"
touch "${HOME}/.parallel/will-cite"

# 并行处理 formulae 和 casks
# Pass --unsafe so that GNU Parallel will not refuse to run in
# directories containing characters that it would otherwise reject.  The
# --will-cite option is unnecessary here because we created the
# ~/.parallel/will-cite file above, but including it explicitly makes
# the intention clear if the file does not yet exist.
parallel --unsafe --will-cite -j 10 --eta --progress "$TEMP_SCRIPT" "$BREW_PREFIX" {} "formula" "$TEMP_DIR" "$ERROR_LOG" ::: $FORMULAE
parallel --unsafe --will-cite -j 10 --eta --progress "$TEMP_SCRIPT" "$BREW_PREFIX" {} "cask" "$TEMP_DIR" "$ERROR_LOG" ::: $CASKS

# 生成 YAML 文件
# 将输出文件写入当前工作目录，而不是硬编码到 ~/Downloads。这样无论从哪里
# 调用脚本，生成的 clash_rules.yaml 都会出现在调用目录中。用户可以
# 根据需要修改文件名，例如 ./clash_rules.yaml。
YAML_FILE="${PWD}/clash_rules.yaml"
echo -e "payload:" > "$YAML_FILE"

# 使用关联数组存储域名和命令
declare -A domain_commands

# 处理 formulae 和 casks
for type in "formula" "cask"; do
  for file in "${TEMP_DIR}/${type}_"*.domain; do
    if [ -f "$file" ]; then
      domain=$(cat "$file")
      command=$(cat "${file%.domain}.command")
      if [ -n "$domain" ] && [ -n "$command" ]; then
        if [ -n "${domain_commands[$domain]}" ]; then
          domain_commands[$domain]="${domain_commands[$domain]} \\ $command"
        else
          domain_commands[$domain]="$command"
        fi
      fi
    fi
  done
done

# 写入 YAML 文件
for domain in "${!domain_commands[@]}"; do
  printf "    - DOMAIN-SUFFIX  , %-40s # 测试命令: %s\n" "$domain" "${domain_commands[$domain]}" >> "$YAML_FILE"
done

# 清理临时文件
rm -rf "$TEMP_DIR"

echo -e "YAML 文件已生成: $YAML_FILE"
