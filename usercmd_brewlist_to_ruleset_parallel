#!/usr/bin/env bash

# 确定 Homebrew 的安装路径
if [ -x /usr/local/bin/brew ]; then
  BREW_PREFIX="/usr/local"
elif [ -x /opt/homebrew/bin/brew ]; then
  BREW_PREFIX="/opt/homebrew"
else
  echo -e "Homebrew 未找到"
  exit 1
fi

# 获取已安装的 formulae 和 casks
FORMULAE=$($BREW_PREFIX/bin/brew list --formula)
CASKS=$($BREW_PREFIX/bin/brew list --cask)

# 创建临时目录存储并行处理结果
TEMP_DIR=$(mktemp -d)
ERROR_LOG="${TEMP_DIR}/error.log"

# 创建临时脚本文件
TEMP_SCRIPT="${TEMP_DIR}/get_url.sh"
cat << 'EOF' > "$TEMP_SCRIPT"
#!/bin/bash
BREW_PREFIX="$1"
PKG="$2"
TYPE="$3"
TEMP_DIR="$4"
ERROR_LOG="$5"

get_url_from_json() {
  local pkg=$1
  local type=$2
  local json_output
  if [ "$type" == "formula" ]; then
    json_output=$($BREW_PREFIX/bin/brew info --json=v2 --formula "$pkg" 2>/dev/null)
  else
    json_output=$($BREW_PREFIX/bin/brew info --json=v2 --cask "$pkg" 2>/dev/null)
  fi

  if echo -e "$json_output" | jq -e '.' > /dev/null 2>&1; then
    local url
    if [ "$type" == "formula" ]; then
      url=$(echo -e "$json_output" | jq -r '.formulae[0].urls.stable.url // empty')
    else
      url=$(echo -e "$json_output" | jq -r '.casks[0].url // empty')
    fi
    if [ -n "$url" ]; then
      echo -e "$url"
    else
      echo -e "无法提取 $pkg 的 URL" >> "$ERROR_LOG"
      echo -e ""
    fi
  else
    echo -e "无法解析 $pkg 的 JSON 输出" >> "$ERROR_LOG"
    echo -e ""
  fi
}

URL=$(get_url_from_json "$PKG" "$TYPE")
if [ -n "$URL" ]; then
  DOMAIN=$(echo -e "$URL" | sed -E 's|https?://([^/]+).*|\1|')
  echo -e "$DOMAIN" > "${TEMP_DIR}/${TYPE}_${PKG}.domain"
  if [ "$TYPE" == "formula" ]; then
    echo -e "brew install $PKG" > "${TEMP_DIR}/${TYPE}_${PKG}.command"
  else
    echo -e "brew install --cask $PKG" > "${TEMP_DIR}/${TYPE}_${PKG}.command"
  fi
fi
EOF

chmod +x "$TEMP_SCRIPT"

# -----------------------------------------------------------------------------
# GNU Parallel configuration
#
# Newer versions of GNU Parallel are more conservative about the characters they
# accept in the current working directory and will print warnings or refuse to
# run unless you explicitly acknowledge the risks.  They also display a
# citation notice on every invocation unless the user confirms they will cite
# the tool.  According to the official GNU Parallel documentation, running
# `parallel --citation` will print the citation notice and silence it for
# future runs, and the `--will-cite` option will silence the notice for the
# current run【876478828081736†L880-L903】.  The same documentation notes that
# the `--unsafe` flag allows Parallel to run in directories containing
# characters outside of its conservative default set【876478828081736†L4056-L4067】.
# To avoid repeated warnings and interactive prompts, we create the
# ~/.parallel/will-cite file once and pass the --unsafe flag when invoking
# parallel.  Creating ~/.parallel/will-cite is equivalent to acknowledging
# that you will cite GNU Parallel; this suppresses the nag for future runs as
# demonstrated in the official guidance【876478828081736†L880-L903】.

# Silence the citation notice permanently by creating the will‑cite file.  If
# ~/.parallel does not exist, create it.  Touching will‑cite here means GNU
# Parallel will skip the citation notice in subsequent runs.
mkdir -p "${HOME}/.parallel"
touch "${HOME}/.parallel/will-cite"

# 并行处理 formulae 和 casks
# Pass --unsafe so that GNU Parallel will not refuse to run in
# directories containing characters that it would otherwise reject.  The
# --will-cite option is unnecessary here because we created the
# ~/.parallel/will-cite file above, but including it explicitly makes
# the intention clear if the file does not yet exist.
parallel --unsafe --will-cite -j 10 --eta --progress "$TEMP_SCRIPT" "$BREW_PREFIX" {} "formula" "$TEMP_DIR" "$ERROR_LOG" ::: $FORMULAE
parallel --unsafe --will-cite -j 10 --eta --progress "$TEMP_SCRIPT" "$BREW_PREFIX" {} "cask" "$TEMP_DIR" "$ERROR_LOG" ::: $CASKS

###############################################################################
# 根据收集到的域名生成三种规则文件：
# 1. MacAppUpgrade_Domain.yaml    —— domain 类型，使用 '+.' 前缀并带有测试命令注释。
# 2. MacAppUpgrade_No_Resolve.yaml —— classical 类型，规则为 DOMAIN-SUFFIX 且在域名后追加 ', no-resolve'。
# 3. MacAppUpgrade.yaml           —— classical 类型，规则为 DOMAIN-SUFFIX。

# 首先再次汇总所有域名与命令，填充 domain_commands 关联数组
declare -A domain_commands
for type in "formula" "cask"; do
  for file in "${TEMP_DIR}/${type}_"*.domain; do
    if [ -f "$file" ]; then
      domain=$(cat "$file")
      command=$(cat "${file%.domain}.command")
      if [ -n "$domain" ] && [ -n "$command" ]; then
        if [ -n "${domain_commands[$domain]}" ]; then
          domain_commands[$domain]="${domain_commands[$domain]} \\ $command"
        else
          domain_commands[$domain]="$command"
        fi
      fi
    fi
  done
done

# 指定输出文件路径
DOMAIN_FILE="${PWD}/MacAppUpgrade_Domain.yaml"
NO_RESOLVE_FILE="${PWD}/MacAppUpgrade_No_Resolve.yaml"
CLASSICAL_FILE="${PWD}/MacAppUpgrade.yaml"

# 头部规则定义
#
# 对于 domain 类型的规则文件（MacAppUpgrade_Domain.yaml），我们使用 '+.' 前缀来指示
# 匹配该域及其子域，因此此处的 header_plus 中只包含裸域名，不带任何前缀。在
# 输出时会显式添加 '+.' 前缀。例如 'brew.sh' 会被渲染成 '+.brew.sh'。
header_plus=(
  "brew.sh"
  "ghcr.io"
  "pkg-containers.githubusercontent.com"
  "raw.githubusercontent.com"
  "github.com"
)

# classical 头部规则（用于 MacAppUpgrade.yaml 和 MacAppUpgrade_No_Resolve.yaml）。
# classical 格式使用 DOMAIN-SUFFIX，并直接写裸域名。
header_classical=(
  "brew.sh"
  "ghcr.io"
  "pkg-containers.githubusercontent.com"
  "raw.githubusercontent.com"
  "github.com"
)

# 计算最大域名长度
max_domain_len=0
for d in "${!domain_commands[@]}"; do
  len=${#d}
  if (( len > max_domain_len )); then
    max_domain_len=$len
  fi
done
# 同时考虑 header_plus 中的域名长度，以便域名和头部规则对齐
for h in "${header_plus[@]}"; do
  hlen=${#h}
  if (( hlen > max_domain_len )); then
    max_domain_len=$hlen
  fi
done
# classical 最大域名长度，考虑头部域
max_header_classical_len=0
for h in "${header_classical[@]}"; do
  hlen=${#h}
  if (( hlen > max_header_classical_len )); then
    max_header_classical_len=$hlen
  fi
done
if (( max_domain_len > max_header_classical_len )); then
  max_classical_len=$max_domain_len
else
  max_classical_len=$max_header_classical_len
fi

# no-resolve 后缀
nr_suffix=", no-resolve"
nr_suffix_len=${#nr_suffix}
nr_total_width=$(( max_classical_len + nr_suffix_len ))

# 生成 Domain 文件
{
  echo -e "payload:\n"
  # plus 头部，对齐注释
  for h in "${header_plus[@]}"; do
    pad=$(( max_domain_len - ${#h} ))
    if (( pad < 0 )); then pad=0; fi
    printf "    - '+.%s' %*s#\n" "$h" "$pad" ""
  done
  echo
  # plus 主体，带测试命令
  for domain in "${!domain_commands[@]}"; do
    pad=$(( max_domain_len - ${#domain} ))
    if (( pad < 0 )); then pad=0; fi
    printf "    - '+.%s' %*s# 测试命令: %s\n" "$domain" "$pad" "" "${domain_commands[$domain]}"
  done
} > "$DOMAIN_FILE"

# 生成 No_Resolve 文件
{
  echo -e "payload:\n"
  # classical 头部，按 no-resolve 总宽度对齐
  for h in "${header_classical[@]}"; do
    pad=$(( nr_total_width - ${#h} ))
    if (( pad < 0 )); then pad=0; fi
    printf "    - DOMAIN-SUFFIX  , %s%*s#\n" "$h" "$pad" ""
  done
  echo
  # classical 主体：域名 + ', no-resolve'
  for domain in "${!domain_commands[@]}"; do
    pad=$(( nr_total_width - ${#domain} - nr_suffix_len ))
    if (( pad < 0 )); then pad=0; fi
    printf "    - DOMAIN-SUFFIX  , %s%s%*s# 测试命令: %s\n" "$domain" "$nr_suffix" "$pad" "" "${domain_commands[$domain]}"
  done
} > "$NO_RESOLVE_FILE"

# 生成 classical 文件
{
  echo -e "payload:\n"
  # classical 头部，对齐
  for h in "${header_classical[@]}"; do
    pad=$(( max_classical_len - ${#h} ))
    if (( pad < 0 )); then pad=0; fi
    printf "    - DOMAIN-SUFFIX  , %s%*s#\n" "$h" "$pad" ""
  done
  echo
  # classical 主体
  for domain in "${!domain_commands[@]}"; do
    pad=$(( max_classical_len - ${#domain} ))
    if (( pad < 0 )); then pad=0; fi
    printf "    - DOMAIN-SUFFIX  , %s%*s# 测试命令: %s\n" "$domain" "$pad" "" "${domain_commands[$domain]}"
  done
} > "$CLASSICAL_FILE"

# 清理临时目录
rm -rf "$TEMP_DIR"

# 输出生成文件路径
echo -e "已生成规则文件:\n  $DOMAIN_FILE\n  $NO_RESOLVE_FILE\n  $CLASSICAL_FILE"
