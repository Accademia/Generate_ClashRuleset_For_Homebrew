#!/usr/bin/env bash

# 确定 Homebrew 的安装路径
if [ -x /usr/local/bin/brew ]; then
  BREW_PREFIX="/usr/local"
elif [ -x /opt/homebrew/bin/brew ]; then
  BREW_PREFIX="/opt/homebrew"
else
  echo -e "Homebrew 未找到"
  exit 1
fi

# 获取已安装的 formulae 和 casks
FORMULAE=$($BREW_PREFIX/bin/brew list --formula)
CASKS=$($BREW_PREFIX/bin/brew list --cask)

# 计算总的软件包数量
TOTAL=$(echo -e "$FORMULAE" | wc -w | tr -d ' ')
TOTAL=$((TOTAL + $(echo -e "$CASKS" | wc -w | tr -d ' ')))
CURRENT=0

# 临时文件存储 domains 和对应的 brew 命令
FORMULA_DOMAIN_FILE=$(mktemp)
FORMULA_COMMAND_FILE=$(mktemp)
CASK_DOMAIN_FILE=$(mktemp)
CASK_COMMAND_FILE=$(mktemp)
ERROR_LOG=$(mktemp)

# 记录开始时间
START_TIME=$(date +%s)

# 函数：显示进度条和预计完成时间
show_progress() {
  local percent=$((CURRENT * 100 / TOTAL))
  local elapsed=$(( $(date +%s) - START_TIME ))
  local remaining=0
  if [ $CURRENT -gt 0 ]; then
    local time_per_package=$(echo -e "scale=2; $elapsed / $CURRENT" | bc)
    remaining=$(echo -e "scale=0; ($TOTAL - $CURRENT) * $time_per_package" | bc)
  fi
  echo -e -ne "\r处理中: $percent% 完成，预计剩余时间: $remaining 秒"
}

# 函数：从 brew info JSON 中提取 URL
get_url_from_json() {
  local pkg=$1
  local type=$2  # "formula" 或 "cask"
  local json_output
  if [ "$type" == "formula" ]; then
    json_output=$($BREW_PREFIX/bin/brew info --json=v2 --formula "$pkg" 2>/dev/null)
  else
    json_output=$($BREW_PREFIX/bin/brew info --json=v2 --cask "$pkg" 2>/dev/null)
  fi

  # 检查输出是否为有效 JSON
  if echo -e "$json_output" | jq -e '.' > /dev/null 2>&1; then
    local url
    if [ "$type" == "formula" ]; then
      url=$(echo -e "$json_output" | jq -r '.formulae[0].urls.stable.url // empty')
    else
      url=$(echo -e "$json_output" | jq -r '.casks[0].url // empty')
    fi
    if [ -n "$url" ]; then
      echo -e "$url"
    else
      echo -e "无法提取 $pkg 的 URL" >> "$ERROR_LOG"
      echo -e ""
    fi
  else
    echo -e "无法解析 $pkg 的 JSON 输出" >> "$ERROR_LOG"
    echo -e ""
  fi
}

# 处理 formulae
for formula in $FORMULAE; do
  URL=$(get_url_from_json "$formula" "formula")
  if [ -n "$URL" ]; then
    DOMAIN=$(echo -e "$URL" | sed -E 's|https?://([^/]+).*|\1|')
    echo -e "$DOMAIN" >> "$FORMULA_DOMAIN_FILE"
    echo -e "brew install $formula" >> "$FORMULA_COMMAND_FILE"
  fi
  CURRENT=$((CURRENT + 1))
  show_progress
done

# 处理 casks
for cask in $CASKS; do
  URL=$(get_url_from_json "$cask" "cask")
  if [ -n "$URL" ]; then
    DOMAIN=$(echo -e "$URL" | sed -E 's|https?://([^/]+).*|\1|')
    echo -e "$DOMAIN" >> "$CASK_DOMAIN_FILE"
    echo -e "brew install --cask $cask" >> "$CASK_COMMAND_FILE"
  fi
  CURRENT=$((CURRENT + 1))
  show_progress
done

echo -e -e "\n处理完成。"

###############################################################################
# 根据收集到的域名生成三种规则文件：
# 1. MacAppUpgrade_Domain.yaml    —— domain 类型，使用 '+.' 前缀并带有测试命令注释。
# 2. MacAppUpgrade_No_Resolve.yaml —— classical 类型，规则为 DOMAIN-SUFFIX 且在域名后追加 ', no-resolve'。
# 3. MacAppUpgrade.yaml           —— classical 类型，规则为 DOMAIN-SUFFIX。

# 输出文件路径
DOMAIN_FILE="${PWD}/MacAppUpgrade_Domain.yaml"
NO_RESOLVE_FILE="${PWD}/MacAppUpgrade_No_Resolve.yaml"
CLASSICAL_FILE="${PWD}/MacAppUpgrade.yaml"

# 头部规则定义
#
# 对于 domain 类型的规则文件（MacAppUpgrade_Domain.yaml），我们使用 '+.' 前缀
# 来指示匹配该域及其子域。此处 header_plus 只包含裸域名，输出时再
# 添加 '+.' 前缀。
header_plus=(
  "brew.sh"
  "ghcr.io"
  "pkg-containers.githubusercontent.com"
  "raw.githubusercontent.com"
  "github.com"
)

# classical 头部规则（用于 MacAppUpgrade.yaml 和 MacAppUpgrade_No_Resolve.yaml）。
# classical 格式使用 DOMAIN-SUFFIX，并直接写裸域名。
header_classical=(
  "brew.sh"
  "ghcr.io"
  "pkg-containers.githubusercontent.com"
  "raw.githubusercontent.com"
  "github.com"
)

# 使用关联数组存储域名与安装命令，合并 formula 和 cask
declare -A domain_commands
{
  paste "$FORMULA_DOMAIN_FILE" "$FORMULA_COMMAND_FILE"
  paste "$CASK_DOMAIN_FILE" "$CASK_COMMAND_FILE"
} | while read -r line; do
  domain=$(echo -e "$line" | cut -f1)
  command=$(echo -e "$line" | cut -f2)
  if [ -n "$domain" ] && [ -n "$command" ]; then
    if [ -n "${domain_commands[$domain]}" ]; then
      domain_commands[$domain]="${domain_commands[$domain]} \\ $command"
    else
      domain_commands[$domain]="$command"
    fi
  fi
done

# 计算最大域名长度
max_domain_len=0
for d in "${!domain_commands[@]}"; do
  len=${#d}
  if (( len > max_domain_len )); then
    max_domain_len=$len
  fi
done
# 同时考虑 header_plus 中的域名长度，以便域名和头部规则对齐
for h in "${header_plus[@]}"; do
  hlen=${#h}
  if (( hlen > max_domain_len )); then
    max_domain_len=$hlen
  fi
done

# classical 最大域名长度（考虑头部域）
max_header_classical_len=0
for h in "${header_classical[@]}"; do
  hlen=${#h}
  if (( hlen > max_header_classical_len )); then
    max_header_classical_len=$hlen
  fi
done
if (( max_domain_len > max_header_classical_len )); then
  max_classical_len=$max_domain_len
else
  max_classical_len=$max_header_classical_len
fi

# no-resolve 后缀
nr_suffix=", no-resolve"
nr_suffix_len=${#nr_suffix}
nr_total_width=$(( max_classical_len + nr_suffix_len ))

# 生成 Domain 文件
{
  echo -e "payload:\n"
  # plus 头部
  for h in "${header_plus[@]}"; do
    pad=$(( max_domain_len - ${#h} ))
    if (( pad < 0 )); then pad=0; fi
    printf "    - '+.%s' %*s#\n" "$h" "$pad" ""
  done
  echo
  # plus 主体
  for domain in "${!domain_commands[@]}"; do
    pad=$(( max_domain_len - ${#domain} ))
    if (( pad < 0 )); then pad=0; fi
    printf "    - '+.%s' %*s# 测试命令: %s\n" "$domain" "$pad" "" "${domain_commands[$domain]}"
  done
} > "$DOMAIN_FILE"

# 生成 No_Resolve 文件
{
  echo -e "payload:\n"
  # classical 头部，对齐到 no-resolve 总宽度
  for h in "${header_classical[@]}"; do
    pad=$(( nr_total_width - ${#h} ))
    if (( pad < 0 )); then pad=0; fi
    printf "    - DOMAIN-SUFFIX  , %s%*s#\n" "$h" "$pad" ""
  done
  echo
  # classical 主体：域名 + no-resolve
  for domain in "${!domain_commands[@]}"; do
    pad=$(( nr_total_width - ${#domain} - nr_suffix_len ))
    if (( pad < 0 )); then pad=0; fi
    printf "    - DOMAIN-SUFFIX  , %s%s%*s# 测试命令: %s\n" "$domain" "$nr_suffix" "$pad" "" "${domain_commands[$domain]}"
  done
} > "$NO_RESOLVE_FILE"

# 生成 classical 文件
{
  echo -e "payload:\n"
  # classical 头部
  for h in "${header_classical[@]}"; do
    pad=$(( max_classical_len - ${#h} ))
    if (( pad < 0 )); then pad=0; fi
    printf "    - DOMAIN-SUFFIX  , %s%*s#\n" "$h" "$pad" ""
  done
  echo
  # classical 主体
  for domain in "${!domain_commands[@]}"; do
    pad=$(( max_classical_len - ${#domain} ))
    if (( pad < 0 )); then pad=0; fi
    printf "    - DOMAIN-SUFFIX  , %s%*s# 测试命令: %s\n" "$domain" "$pad" "" "${domain_commands[$domain]}"
  done
} > "$CLASSICAL_FILE"

# 清理临时文件
rm "$FORMULA_DOMAIN_FILE" "$FORMULA_COMMAND_FILE" "$CASK_DOMAIN_FILE" "$CASK_COMMAND_FILE"

# 打印错误日志
if [ -s "$ERROR_LOG" ]; then
  echo -e "以下软件包处理时遇到问题："
  cat "$ERROR_LOG"
fi
rm "$ERROR_LOG"

# 输出生成文件路径
echo -e "已生成规则文件:\n  $DOMAIN_FILE\n  $NO_RESOLVE_FILE\n  $CLASSICAL_FILE"
