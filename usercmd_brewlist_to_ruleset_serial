#!/usr/bin/env bash

# 确定 Homebrew 的安装路径
if [ -x /usr/local/bin/brew ]; then
  BREW_PREFIX="/usr/local"
elif [ -x /opt/homebrew/bin/brew ]; then
  BREW_PREFIX="/opt/homebrew"
else
  echo -e "Homebrew 未找到"
  exit 1
fi

# 获取已安装的 formulae 和 casks
FORMULAE=$($BREW_PREFIX/bin/brew list --formula)
CASKS=$($BREW_PREFIX/bin/brew list --cask)

# 计算总的软件包数量
TOTAL=$(echo -e "$FORMULAE" | wc -w | tr -d ' ')
TOTAL=$((TOTAL + $(echo -e "$CASKS" | wc -w | tr -d ' ')))
CURRENT=0

# 临时文件存储 domains 和对应的 brew 命令
FORMULA_DOMAIN_FILE=$(mktemp)
FORMULA_COMMAND_FILE=$(mktemp)
CASK_DOMAIN_FILE=$(mktemp)
CASK_COMMAND_FILE=$(mktemp)
ERROR_LOG=$(mktemp)

# -----------------------------------------------------------------------------
# GNU Parallel configuration (for consistency)
#
# Although this serial version of the script does not call GNU Parallel,
# your environment may include other scripts which do.  Recent versions of
# GNU Parallel display a citation notice on every run and refuse to run in
# directories with certain characters unless you explicitly allow it.  The
# official manual explains that running `parallel --citation` once will print
# the citation notice and silence it for future runs, and `--will-cite` can
# suppress the notice for a single run【876478828081736†L880-L903】.  It also
# notes that the `--unsafe` option permits execution in directories containing
# otherwise unsafe characters【876478828081736†L4056-L4067】.
# To prevent unexpected warnings when you call parallel from other scripts,
# we proactively create the `~/.parallel/will-cite` file here.  This
# acknowledges the citation request and prevents the nag from appearing.  If
# ~/.parallel does not exist, it is created.
mkdir -p "${HOME}/.parallel"
touch "${HOME}/.parallel/will-cite"

# 记录开始时间
START_TIME=$(date +%s)

# 函数：显示进度条和预计完成时间
show_progress() {
  local percent=$((CURRENT * 100 / TOTAL))
  local elapsed=$(( $(date +%s) - START_TIME ))
  local remaining=0
  if [ $CURRENT -gt 0 ]; then
    local time_per_package=$(echo -e "scale=2; $elapsed / $CURRENT" | bc)
    remaining=$(echo -e "scale=0; ($TOTAL - $CURRENT) * $time_per_package" | bc)
  fi
  echo -e -ne "\r处理中: $percent% 完成，预计剩余时间: $remaining 秒"
}

# 函数：从 brew info JSON 中提取 URL
get_url_from_json() {
  local pkg=$1
  local type=$2  # "formula" 或 "cask"
  local json_output
  if [ "$type" == "formula" ]; then
    json_output=$($BREW_PREFIX/bin/brew info --json=v2 --formula "$pkg" 2>/dev/null)
  else
    json_output=$($BREW_PREFIX/bin/brew info --json=v2 --cask "$pkg" 2>/dev/null)
  fi

  # 检查输出是否为有效 JSON
  if echo -e "$json_output" | jq -e '.' > /dev/null 2>&1; then
    local url
    if [ "$type" == "formula" ]; then
      url=$(echo -e "$json_output" | jq -r '.formulae[0].urls.stable.url // empty')
    else
      url=$(echo -e "$json_output" | jq -r '.casks[0].url // empty')
    fi
    if [ -n "$url" ]; then
      echo -e "$url"
    else
      echo -e "无法提取 $pkg 的 URL" >> "$ERROR_LOG"
      echo -e ""
    fi
  else
    echo -e "无法解析 $pkg 的 JSON 输出" >> "$ERROR_LOG"
    echo -e ""
  fi
}

# 处理 formulae
for formula in $FORMULAE; do
  URL=$(get_url_from_json "$formula" "formula")
  if [ -n "$URL" ]; then
    DOMAIN=$(echo -e "$URL" | sed -E 's|https?://([^/]+).*|\1|')
    echo -e "$DOMAIN" >> "$FORMULA_DOMAIN_FILE"
    echo -e "brew install $formula" >> "$FORMULA_COMMAND_FILE"
  fi
  CURRENT=$((CURRENT + 1))
  show_progress
done

# 处理 casks
for cask in $CASKS; do
  URL=$(get_url_from_json "$cask" "cask")
  if [ -n "$URL" ]; then
    DOMAIN=$(echo -e "$URL" | sed -E 's|https?://([^/]+).*|\1|')
    echo -e "$DOMAIN" >> "$CASK_DOMAIN_FILE"
    echo -e "brew install --cask $cask" >> "$CASK_COMMAND_FILE"
  fi
  CURRENT=$((CURRENT + 1))
  show_progress
done

echo -e -e "\n处理完成。"

# 生成 YAML 文件到当前目录
# 将输出文件写入脚本执行目录，而不是硬编码到 ~/Downloads。这样无论从哪里
# 调用脚本，生成的 clash_rules.yaml 都会出现在调用目录中。
YAML_FILE="${PWD}/clash_rules.yaml"
echo -e "payload:" > "$YAML_FILE"

# 去重并排序 formulae 的 domains 并写入 YAML
paste "$FORMULA_DOMAIN_FILE" "$FORMULA_COMMAND_FILE" | sort -u -k1,1 | while read -r line; do
  domain=$(echo -e "$line" | cut -f1)
  command=$(echo -e "$line" | cut -f2)
  printf "    - DOMAIN-SUFFIX  , %-40s # 测试命令: %s\n" "$domain" "$command" >> "$YAML_FILE"
done

# 去重并排序 casks 的 domains 并追加到 YAML
paste "$CASK_DOMAIN_FILE" "$CASK_COMMAND_FILE" | sort -u -k1,1 | while read -r line; do
  domain=$(echo -e "$line" | cut -f1)
  command=$(echo -e "$line" | cut -f2)
  printf "    - DOMAIN-SUFFIX  , %-40s # 测试命令: %s\n" "$domain" "$command" >> "$YAML_FILE"
done

# 清理临时文件
rm "$FORMULA_DOMAIN_FILE" "$FORMULA_COMMAND_FILE" "$CASK_DOMAIN_FILE" "$CASK_COMMAND_FILE"

# 打印错误日志
if [ -s "$ERROR_LOG" ]; then
  echo -e "以下软件包处理时遇到问题："
  cat "$ERROR_LOG"
fi
rm "$ERROR_LOG"

echo -e "YAML 文件已生成: $YAML_FILE"
